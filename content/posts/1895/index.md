---
title: OpenWrt如何借助实现特殊功能？
date: 2021-07-21T00:00:00+00:00
draft: true
categories:
  - 网络基础
  - Linux

---
相信有不少人在用OpenWrt的某些插件出去查找资料，但是很少有文章把路由器上怎么实现这一功能的原理给讲清了。本文不教如何使用并且也不提倡使用，但是其背后实现细节，不得不一句感叹：Linux yyds！

## 前言

相信有很多人都在用OpenWrt的某些插件吧。作为开发者和研究员来说，出去查查资料还是很有必要的，那在路由器上是怎么做到这个能力的，这就不得不说Linux永远滴神了。最近正好有朋友问到，再加上这块内容一直缺少资料，本身就是Linux的一些内核特性而已，但是至今没有见到多少文章能够把实现细节讲明白了，因此本次，博主我专门出了一篇文章来深究一下，这背后的Linux到底都做了啥？

Linux本身的netfilter的nat表中支持了REDIRECT和TPROXY两个Action，由于时间关系，本文着重介绍REDIRECT（重定向）的实现（TCP用），TPROXY的实现（UDP用）则在后续有时间时再继续更新。

## 总览iptables规则

在整个实现里，最重要的就是iptables的规则了，我拎出来了一个插件安装在系统上的规则，一起来看看。

```bash
# Generated by iptables-save v1.8.3 on Sat Jul 24 19:44:47 2021
*nat

# 第一部分
-A PREROUTING -i eth0 -p tcp -m comment -j SPEC_WAN_AC

# 第二部分
-A OUTPUT -p tcp -m comment -j SPEC_WAN_AC

# 第三部分
-A SPEC_WAN_AC -m set --match-set whitelist dst -j RETURN
-A SPEC_WAN_AC -m set --match-set blacklist dst -j SPEC_WAN_FW
-A SPEC_WAN_AC -m set --match-set china dst -j RETURN
-A SPEC_WAN_AC -m set --match-set gmlan src -m set ! --match-set china dst -j SPEC_WAN_FW
-A SPEC_WAN_AC -j SPEC_WAN_FW

# 第四部分
-A SPEC_WAN_FW -d 0.0.0.0/8 -j RETURN
-A SPEC_WAN_FW -d 10.0.0.0/8 -j RETURN
-A SPEC_WAN_FW -d 127.0.0.0/8 -j RETURN
-A SPEC_WAN_FW -d 169.254.0.0/16 -j RETURN
-A SPEC_WAN_FW -d 172.16.0.0/12 -j RETURN
-A SPEC_WAN_FW -d 192.168.0.0/16 -j RETURN
-A SPEC_WAN_FW -d 224.0.0.0/4 -j RETURN
-A SPEC_WAN_FW -d 240.0.0.0/4 -j RETURN
-A SPEC_WAN_FW -p tcp -m multiport --dports 22,53,587,465,995,993,143,80,443,853,9418 -j REDIRECT --to-ports 1234

COMMIT
# Completed on Sat Jul 24 19:44:47 2021
```

在第一和第二部分中，PREROUTING链的规则匹配到了所有从eth0接口进来的并且协议为TCP的数据包，OUTPUT链的规则则匹配到了所有从本机IP出去的TCP数据包。这两部分的包在匹配到之后，均跳转到SPEC_WAN_AC链上执行。

在第三部分中，数据包沿着SPEC_WAN_AC这条链开始走动，分别对应下边的流程：

  1. 匹配到目标地址在whitelist中时，执行RETURN
  2. 匹配到目标地址在blacklist中时，跳转到SPEC_WAN_FW
  3. 匹配到目标地址在china中时，执行RETURN
  4. 匹配到目标地址在gmlan并且源地址不在china中时，跳转到SPEC_WAN_FW
  5. 跳转到SPEC_WAN_FW。该条为该链下的最后一条，匹配整条链走完之后还没有匹配到的数据包（不含RETURN的）

-m set为ipset插件支持的功能，借助哈希表实现，将IP地址甚至端口号进行哈希（至于是多项式哈希还是转成了字节序就不清楚了，此处先不详谈这个），这样一来，当在几十万几百万的地址中进行匹配时，就能达到O(1)的时间复杂度，而不必再逐个按顺序匹配。试想一下，如果有100万的地址块，用iptables的规则，那么就需要添加100万条规则来匹配，如果某个数据包很不幸它的目的IP刚好在第100万条，那么相当于前99万9999条都是在匹配并且未命中，一直在等待转发，这样一来转发延迟的抖动可想而知。

RETURN操作即返回，当数据包匹配到规则执行RETURN时，即回到了其父链（在这里是PREROUTING或者OUPUT）中继续向下匹配。

> RETURN means stop traversing this chain and resume at the next rule in the previous (calling) chain. If the end of a built-in chain is reached or a rule in a built-in chain with target RETURN is matched, the target specified by the chain policy determines the fate of the packet.
> 
> iptables(8) - Linux man page. https://linux.die.net/man/8/iptables

-j SPEC_WAN_FW为跳转匹配到的数据包到SPEC_WAN_FW链上继续执行。

> -j, -ump target
> 
> This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below). If this option is omitted in a rule (and -g is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
> 
> iptables(8) - Linux man page. https://linux.die.net/man/8/iptables

在第四部分中，数据包沿着SPEC_WAN_FW开始走动。将**分别**匹配到目的地址为0.0.0.0/8、10.0.0.0/8、127.0.0.0/8、169.254.0.0/16、172.16.0.0/12、192.168.0.0/16、224.0.0.0/4、240.0.0.0/4的数据包进行RETURN。此处为什么要给分别加粗呢？因为我们时刻得记住，iptables的规则一定是从上向下挨个执行的，因此在这条链中，匹配也就沿着从上到下的顺序依次匹配，是不是觉得效率很低？确实是这样，因此才会有了nftable和索引型匹配（ipset）等的支持。

好戏来了，我们仔细看看，在第四部分的最后一条中，出现了一条REDIRECT。

## REDIRECT实现了什么？

我们来看看社区官方对其的解释：

> This target is only valid in the nat table, in the PREROUTING and OUTPUT chains, and user-defined chains which are only called from those chains.
> 
> It redirects the packet to the machine itself by changing the destination IP to the primary address of the incoming interface (locally-generated packets are mapped to the 127.0.0.1 address). It takes one option:
> 
> -to-ports port[-port] This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies -p tcp or -p udp.
> 
> iptables(8) - Linux man page. https://linux.die.net/man/8/iptables

大意就是说，REDIRECT重定向了数据包到这台机器本身。重定向的实现通过DNAT的方式实现——即将所有的目标IP地址修改为127.0.0.1，进而再通过路由将包路由到系统的协议栈中去。





在进入TPROXY的内容之前，我先补充一个内容。通常情况下，我们理解TCP为有状态的，而UDP为无状态的，确实是没错，计算机网络中也一直这样强调。但是！站在状态防火墙的角度来讲，TCP是有状态的，UDP也是有状态的，甚至ICMP也是有状态的！

为什么呢？我们来想一想，在一个网关上，配置了SNAT（包含MASQUERADE），如果路由器在进行SNAT时，就真的原封不动把数据包改一下头部，其他什么也不做的话，那么我们的数据包怎么回去到内网的主机？这真是个好问题。在这种背景下，ConnTrack诞生了。在Linux的netfilter的Raw表中，